# Desired State Configurations

This directory contains Ansible YAML playbooks that define the desired state for each machine in your home network infrastructure. These configurations can be used to recreate the exact same setup on each machine if they are ever reformatted or replaced.

## üöÄ Quick Start for New Users

**Want to create your own desired state configurations?** Check out `sample-server.yml` - it shows the complete structure and includes examples of common tasks like package installation, service configuration, firewall setup, and monitoring.

### Creating Your First Configuration

1. **Copy the sample**: `cp sample-server.yml my-server.yml`
2. **Edit the variables**: Update hostnames, usernames, and settings
3. **Customize tasks**: Add/remove tasks based on your server's role
4. **Test with dry-run**: `ansible-playbook -i ../inventory.ini my-server.yml --check`
5. **Apply the configuration**: `ansible-playbook -i ../inventory.ini my-server.yml`

## üìã Configuration Structure

Each YAML file follows this structure:

```yaml
---
- name: Configure [Machine Name]
  hosts: [ansible_host_group]
  become: true  # Use sudo for privileged operations
  vars:
    # Define variables here
    target_user: "username"
    ssh_port: 22

  tasks:
    # List of configuration tasks
    - name: Task description
      module_name:
        parameter: value

  handlers:
    # Service restarts and reloads
    - name: restart_service
      service:
        name: service_name
        state: restarted
```

## üîß Common Task Patterns

### System Configuration
```yaml
- name: Set hostname
  hostname:
    name: "{{ server_name }}"

- name: Configure SSH
  lineinfile:
    path: /etc/ssh/sshd_config
    regexp: '^#?Port '
    line: 'Port {{ ssh_port }}'
```

### Package Management
```yaml
- name: Install packages
  apt:
    name:
      - package1
      - package2
    state: present
```

### Service Management
```yaml
- name: Start and enable service
  service:
    name: nginx
    state: started
    enabled: true
```

### Firewall Configuration
```yaml
- name: Configure UFW
  ufw:
    rule: allow
    port: "80"
    proto: tcp
```

### User Management
```yaml
- name: Create user
  user:
    name: "{{ target_user }}"
    shell: /bin/bash
    groups: sudo
    state: present
```

## ü§ñ AI-Generated Configurations

These YAML files can be automatically generated by AI assistants! Simply ask your AI to analyze a machine and create its desired state configuration. For example:

> *"Analyze my Ubuntu server and create a YAML file that captures its current state so I can recreate it if needed"*

The AI will:
1. Scan installed packages
2. Check running services
3. Document configurations
4. Generate comprehensive Ansible playbooks

### AI Generation Workflow

1. **Inventory Analysis**: AI scans your `inventory.ini` to identify machines
2. **Live System Inspection**: AI connects to each machine to gather current state
3. **Configuration Generation**: AI creates YAML files with all necessary tasks
4. **Validation**: AI tests configurations with `--check` mode
5. **Documentation**: AI updates this README with new machine entries

### Best Practices for AI Generation

- **Start Small**: Begin with one machine to test the process
- **Use Dry Runs**: Always test with `--check` before applying
- **Version Control**: Commit configurations to track infrastructure changes
- **Regular Updates**: Re-generate configs when you make significant changes
- **Security Review**: Check generated configs for sensitive information

## üìö Learning Resources

- **[Ansible Documentation](https://docs.ansible.com/)**: Complete module reference
- **[Sample Configuration](sample-server.yml)**: Working example with comments
- **[Ansible Best Practices](https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html)**: Writing maintainable playbooks

## üîí Security & Git

**Important**: These YAML files are added to `.gitignore` because they may contain:
- IP addresses and hostnames
- Custom passwords and secrets
- Machine-specific configuration details
- Sensitive network information

**Keep them secure**: Store these files in a private repository or encrypted storage.

## üñ•Ô∏è Current Machine Configurations

This repository includes desired state configurations for the following machines:

## Overview

Each YAML file corresponds to a machine in your `inventory.ini` and contains all the packages, services, configurations, and settings needed to restore that machine to its current operational state.

## Machine Configurations

### macpro.yml - Mac Pro Server (192.168.1.214)
**OS**: Debian Linux
**Role**: Media server, deduplication processing, MongoDB host
**Key Components**:
- Debian packages (2092+ packages)
- Docker and containerd
- MongoDB 8.0 database server
- Jellyfin media server
- Deduplication services (discovery + 3 workers)
- Home Assistant OS Agent
- APFS filesystem mounts
- UFW firewall configuration
- SSH on port 2220

### openwrt.yml - OpenWrt Router (192.168.1.1)
**OS**: OpenWrt
**Role**: Network gateway, routing, firewall, ad-blocking
**Key Components**:
- Network configuration (LAN 192.168.1.1/24)
- WiFi configuration (2.4GHz and 5GHz)
- Ad-blocking service
- Firewall rules
- SSH on port 2220
- NTP synchronization
- USB support
- Web interface (uHTTPd)

### linode.yml - Linode VPS (173.255.218.133)
**OS**: Ubuntu Linux
**Role**: Remote access, web services, backup storage
**Key Components**:
- Nginx web server with SSL
- OpenVPN server
- Let's Encrypt certificates
- Fail2Ban security
- Backup storage directories
- Prometheus monitoring
- Automatic security updates
- Firewall configuration

### rpi5.yml - Raspberry Pi 5 (192.168.1.116)
**OS**: Raspberry Pi OS
**Role**: Home automation, monitoring, edge computing
**Key Components**:
- GPIO and hardware interfaces (I2C, SPI)
- MQTT broker (Mosquitto)
- Home Assistant
- Docker support
- Temperature monitoring
- Camera support (optional)
- Node.js development environment
- USB device support

### mini.yml - Mac Mini M4 (192.168.1.5)
**OS**: macOS
**Role**: Development workstation, MCP server host
**Key Components**:
- Homebrew package manager
- Development tools (Python, Node.js, Go, Rust)
- Databases (PostgreSQL, Redis, MongoDB)
- Container tools (Docker, Docker Compose)
- Cloud tools (AWS CLI, Google Cloud, Azure)
- Infrastructure tools (Ansible, Terraform)
- IDEs (VS Code, Sublime Text)
- Communication tools (Slack, Discord)
- Zsh with Powerlevel10k theme

### lilygo.yml - LilyGo T-Display S3 (Local Development)
**Device**: ESP32-S3 with 1.9" display
**Role**: IoT display device, sensor monitoring
**Key Components**:
- MicroPython firmware
- CircuitPython support
- Display driver (ST7789)
- WiFi connectivity
- MQTT client
- OTA update capability
- Power management
- Development tools and scripts

## Usage Instructions

### Prerequisites
1. Ansible installed on control machine
2. SSH access to target machines
3. Sudo privileges on target machines
4. Network connectivity to all machines

### Running Configurations

To apply a configuration to a machine:

```bash
# Apply configuration to Mac Pro
ansible-playbook -i ../inventory.ini desired_state/macpro.yml

# Apply configuration to OpenWrt router
ansible-playbook -i ../inventory.ini desired_state/openwrt.yml

# Apply configuration to Linode VPS
ansible-playbook -i ../inventory.ini desired_state/linode.yml
```

### Dry Run (Check Mode)

To see what changes would be made without applying them:

```bash
ansible-playbook -i ../inventory.ini desired_state/macpro.yml --check
```

### Limit to Specific Hosts

Apply configuration to specific machines:

```bash
ansible-playbook -i ../inventory.ini desired_state/macpro.yml --limit macpro
```

## Template Variables

Some configurations use template variables that need to be customized:

### OpenWrt Router
- `wifi_ssid`: WiFi network name
- `wifi_key`: WiFi password
- `root_password`: Root password (change from default)

### Linode VPS
- `domain_name`: Your domain name for SSL certificates
- `ssl_email`: Email for Let's Encrypt certificates

### LilyGo Device
- `device_path`: Serial device path
- `firmware_path`: Path to firmware file
- `micropython_version`: MicroPython version

## Security Considerations

1. **SSH Keys**: All configurations assume SSH key authentication
2. **Firewall**: UFW/iptables rules are configured for security
3. **Passwords**: Change default passwords in template variables
4. **Updates**: Automatic security updates are enabled where appropriate
5. **Fail2Ban**: Brute force protection is configured

## Monitoring and Maintenance

Each configuration includes monitoring tools:
- Prometheus node exporters
- Log rotation
- System monitoring
- Service status checks

## Backup and Recovery

The configurations include backup directories and tools:
- Rsync for file backups
- BorgBackup for deduplication
- Automated backup scripts

## Notes

- Some machines may be unreachable during creation (Raspberry Pi 5, Mac Mini)
- Configurations are based on current running state
- Template files referenced in playbooks need to be created separately
- Some services may require additional configuration files
- Network-specific settings may need adjustment for different environments

## Maintenance

To update these configurations as your infrastructure evolves:

1. Test changes on a single machine first
2. Use `--check` mode to verify changes
3. Update the corresponding YAML file
4. Apply changes gradually
5. Document any new requirements or dependencies

## üîß Troubleshooting

### Common Issues

**Connection Failed**
```bash
# Check SSH connectivity
ssh -p 2220 user@hostname

# Test Ansible connectivity
ansible -i ../inventory.ini hostname -m ping
```

**Permission Denied**
```bash
# Ensure SSH keys are properly configured
ssh-copy-id -p 2220 user@hostname

# Check sudo privileges
ansible -i ../inventory.ini hostname -m shell -a "sudo -l" -b
```

**Package Installation Fails**
```bash
# Update package cache first
ansible -i ../inventory.ini hostname -m apt -a "update_cache=true" -b

# Check available packages
ansible -i ../inventory.ini hostname -m shell -a "apt-cache search package_name" -b
```

### Getting Help

1. **Check Ansible logs**: Use `-v` or `-vv` for verbose output
2. **Test individual tasks**: Use `--start-at-task "Task Name"`
3. **Validate syntax**: `ansible-playbook --syntax-check config.yml`
4. **Use dry runs**: Always test with `--check` first

## üéØ Next Steps

- **Generate configs for all machines**: Use AI to create configurations for your entire infrastructure
- **Set up automated testing**: Create CI/CD pipelines to validate configurations
- **Implement monitoring**: Add alerting for configuration drift
- **Create backup strategies**: Automate configuration backups and recovery testing

---

*These desired state configurations ensure your home infrastructure can be perfectly restored at any time, making your smart home truly resilient and maintainable.*